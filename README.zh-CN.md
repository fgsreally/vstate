# vState

一个基于 vue 的有限状态机，灵感来源自<a href="https://github.com/statelyai/xstate">xstate</a>,

--目前来讲，只是一种尝试，别在生产项目里耍杂技

#### 目标

- ts 支持
- 更加轻量
- 尽可能还原 xstate 的基本操作
- 可以复用 xstate 的代码生成器（vscode/web)
- 树式结构，而非图式，逻辑更易于理解
- 更符合响应式

## 什么是有限状态机

假设有这么几种状态，“吃饭” “睡觉”“看手机”，我在中午的时候有且仅有可能是在这三个状态中，那么我早上就可以对此做出规划，如果吃饭,那应该去哪里吃等等。在项目或者组件中，如果能清晰地判断每一种状态，那么无论是在具体完成代码的过程中，还是在后期的维护中，都会更加轻松。

## 状态节点

在 vstate 中，每一个状态就是树上的一个节点，节点之间又存在各种关系。
有如下几种关系：

- 平行关系，如“吃饭”“看手机”，两者并不存在谁更高级
- 从属关系，如“吃饭”“吃饭时候看手机”，后者就是前者的一个子状态
  这个并不一定，取决于自己定义，你可以去把看手机看成一个子状态，也可以是一个同级的状态

存在以下这几种节点，

- 正常：比如“吃饭”“睡觉” ，鉴于我个人不能同时做到这两件事，我姑且认为这两种状态是互斥的，该节点对应其中的一种
- 并行：比如“吃饭”“看手机”，这两个状态可以同时存在，那么这个节点就同时对应两个状态
- 终结节点，在一个状态的子状态中，存在一个最终状态，比如“吃饭”这个状态中，可能有各种子状态，比如看手机等，假设有一个子状态是“吃完了”，那么到这个状态的时候，就意味着“吃饭”这个状态结束了，要从这个父状态退出，进入下一个父状态，比如睡觉
- 历史节点：在一个状态的子状态中，存在一个历史状态，当我从父状态中退出并到下一个父状态时，可能需要在推出前记住当时最后的状态，就好比我在“家里”这个状态中“写代码”，要“出门”去吃个饭，回到家接着“写代码”，回到“家里”这个状态时，我就需要历史节点从而回到“写代码”这个状态中

存在以下这几种状态切换

- on，手动控制状态切换
- always，每做一次操作，自动进行切换
- invoke，异步行为导致的状态切换，自动进行切换
- after，某段时间后进行切换，自动进行切换
- initial 初始化的状态切换，自动进行切换

状态切换具体是这样：每一次切换存在一步或者多步，每一步分为三个部分（不算 initia）

- 守卫
- 目标状态
- 事件

只有通过了守卫，才会进行真正的切换，并执行事件，第一步失败就会走第二步（如果有的话），成功了就不会
当然也可以把这三个部分置空，比如此时可以没有守卫 or 没有目标

## 上下文与事件

不可能所有东西都用状态来表示，比如计数器上的数字，不可能把每一个数字都设为一个状态，可以把它放到上下文中，事件是不会影响状态的，它只会改变上下文（姑且可以把这两个东西，理解为 pinia 的 state 和 action）

可以在这些过程中触发事件

- 所有的状态切换（除了 initial）
- enter，进入状态时自动执行
- exit，离开时自动执行

## 树型结构

在 xstate 中可以很自由的从“吃饭时看手机”到“入梦”，也可以反过来（如果你真这么设置的话），这有点像一个 graph，每个节点都可以自由地移动向另一个节点，但考虑这种情况：我回到房间先看了会儿手机，然后人精神了结果睡不着了，那么就不能到“入梦”这个状态，我可能先在“回到房间”这个状态中写了很复杂地逻辑，比如我一定会先喝水再睡觉，如果玩手机了可能睡不着等等，那么我在写吃饭这个状态的时候，我不可能自由地切换到入梦，如果强行这样的话会导致写好的这些逻辑全部不作为，而如果不强行，那么很有可能到不了预期地状态（当状态不可估计时，有限状态机没有什么意义）
（实际上我只是单纯觉得这样写很复杂。。）
vstate 中是这样地：我想从“吃饭时看手机”到“入梦”，那我必须先从“吃饭时看手机”退到吃饭，再从吃饭到“回到房间”，再判断具体情况。简而言之，就是从一条子树到另一条子树，需要在哪个状态切换，那就要先从其子状态中退回过来。步骤会更加复杂，但也更可控

## 从 pinia 开始

实际上 pinia 中的 state、actions、getter，可以轻松地并入 vstate，换言之，vstate 就是一个加了有限状态的 pinia。
可以通过简单的ast置换来将pinia转换为vstate ，或者相反
```

```
